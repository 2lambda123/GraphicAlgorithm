#version 430 core
#pragma optionNV (unroll all)	
#define LOCAL_GROUP_SIZE 32
// This is set at the limit of providing unnatural results for sharpening.
#define FSR_RCAS_LIMIT (0.25-(1.0/16.0))
layout (local_size_x = LOCAL_GROUP_SIZE, local_size_y = LOCAL_GROUP_SIZE) in;
layout (rgba32f, binding = 1) uniform writeonly image2D u_OutputRCASImage;

uniform sampler2D u_RASUTexture;
uniform vec4 con;
vec4 FsrRcasLoadF(ivec2 p) { return texelFetch(u_RASUTexture, ivec2(p), 0); }
float Max3F1(float x,float y,float z){return max(x,max(y,z));}
float Min3F1(float x,float y,float z){return min(x,min(y,z));}

void FsrRcasF(out float pixR,out float pixG,out float pixB,ivec2 ip) { // Constant generated by RcasSetup().
	  // Algorithm uses minimal 3x3 pixel neighborhood.
	  //    b 
	  //  d e f
	  //    h
	 ivec2 sp = ivec2(ip);
	 vec3 b = FsrRcasLoadF(sp + ivec2(0, -1)).rgb;
	 vec3 d = FsrRcasLoadF(sp + ivec2(-1, 0)).rgb;
	 vec3 e = FsrRcasLoadF(sp).rgb;
	 vec3 f = FsrRcasLoadF(sp + ivec2(1, 0)).rgb;
	 vec3 h = FsrRcasLoadF(sp + ivec2(0, 1)).rgb;
	 // Rename (32-bit) or regroup (16-bit).
	 float bR = b.r;
	 float bG = b.g;
	 float bB = b.b;
	 float dR = d.r;
	 float dG = d.g;
	 float dB = d.b;
	 float eR = e.r;
	 float eG = e.g;
	 float eB = e.b;
	 float fR = f.r;
	 float fG = f.g;
	 float fB = f.b;
	 float hR = h.r;
	 float hG = h.g;
	 float hB = h.b;
	 // Luma times 2.
	 float bL = bB * 0.5f + (bR * 0.5f + bG);
	 float dL = dB * 0.5f + (dR * 0.5f + dG);
	 float eL = eB * 0.5f + (eR * 0.5f + eG);
	 float fL = fB * 0.5f + (fR * 0.5f + fG);
	 float hL = hB * 0.5f + (hR * 0.5f + hG);
	 // Noise detection.
	 float nz = 0.25f * bL + 0.25f * dL + 0.25f * fL + 0.25f * hL - eL;
	 nz = clamp(abs(nz) * (1.0f / (Max3F1(Max3F1(bL, dL, eL), fL, hL) - Min3F1(Min3F1(bL, dL, eL), fL, hL))),0,1);
	 nz = -0.5f * nz + 1.0;
	 // Min and max of ring.
	 float mn4R = min(Min3F1(bR, dR, fR), hR);
	 float mn4G = min(Min3F1(bG, dG, fG), hG);
	 float mn4B = min(Min3F1(bB, dB, fB), hB);
	 float mx4R = max(Max3F1(bR, dR, fR), hR);
	 float mx4G = max(Max3F1(bG, dG, fG), hG);
	 float mx4B = max(Max3F1(bB, dB, fB), hB);
	 // Immediate constants for peak range.
	 vec2 peakC = vec2(1.0, -1.0*4.0);
	 // Limiters, these need to be high precision RCPs.
	 float hitMinR = mn4R * (1.0f / (4.0f * mx4R));
	 float hitMinG = mn4G * (1.0f / (4.0f * mx4G));
	 float hitMinB = mn4B * (1.0f / (4.0f * mx4B));
	 float hitMaxR = (peakC.x - mx4R) * (1.0f / (4.0f * mn4R + peakC.y));
	 float hitMaxG = (peakC.x - mx4G) * (1.0f / (4.0f * mn4G + peakC.y));
	 float hitMaxB = (peakC.x - mx4B) * (1.0f / (4.0f * mn4B + peakC.y));
	 float lobeR = max(-hitMinR, hitMaxR);
	 float lobeG = max(-hitMinG, hitMaxG);
	 float lobeB = max(-hitMinB, hitMaxB);
	 float lobe = max(float(-FSR_RCAS_LIMIT), min(Max3F1(lobeR, lobeG, lobeB), 0.0)) * (con.x);
	 // Apply noise removal.
#ifdef FSR_RCAS_DENOISE
	 lobe *= nz;
#endif
	 // Resolve, which needs the medium precision rcp approximation to avoid visible tonality changes.
	 float rcpL = 1.0f / (4.0f * lobe + 1.0f);
	 pixR = (lobe*bR + lobe * dR + lobe * hR + lobe * fR + eR)*rcpL;
	 pixG = (lobe*bG + lobe * dG + lobe * hG + lobe * fG + eG)*rcpL;
	 pixB = (lobe*bB + lobe * dB + lobe * hB + lobe * fB + eB)*rcpL;
 }

void main()
{
	ivec2 FragPos = ivec2(gl_GlobalInvocationID.xy);
	vec3 color = vec3(0);
	FsrRcasF(color.r,color.g,color.b,FragPos);
	imageStore(u_OutputRCASImage, FragPos, vec4(color, 1));
}