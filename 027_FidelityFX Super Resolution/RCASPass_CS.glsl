#version 430 core
#pragma optionNV (unroll all)	
#define LOCAL_GROUP_SIZE 32
// This is set at the limit of providing unnatural results for sharpening.
#define FSR_RCAS_LIMIT (0.25-(1.0/16.0))
layout (local_size_x = LOCAL_GROUP_SIZE, local_size_y = LOCAL_GROUP_SIZE) in;
layout (rgba32f, binding = 1) uniform writeonly image2D u_OutputRCASImage;

uniform sampler2D u_RASUTexture;
uniform vec4 con;
vec4 FsrRcasLoadF(ivec2 p) { return texelFetch(u_RASUTexture, ivec2(p), 0); }
float ARcpF1(float x) {return 1.0f / x;}
float AMax3F1(float x,float y,float z){return max(x,max(y,z));}
float AMin3F1(float x,float y,float z){return min(x,min(y,z));}

void FsrRcasF(out float pixR,out float pixG,out float pixB,ivec2 ip) { // Constant generated by RcasSetup().
	  // Algorithm uses minimal 3x3 pixel neighborhood.
	  //    b 
	  //  d e f
	  //    h
	 ivec2 sp = ivec2(ip);
	 vec3 b = FsrRcasLoadF(sp + ivec2(0, -1)).rgb;
	 vec3 d = FsrRcasLoadF(sp + ivec2(-1, 0)).rgb;
	 vec3 e = FsrRcasLoadF(sp).rgb;
	 vec3 f = FsrRcasLoadF(sp + ivec2(1, 0)).rgb;
	 vec3 h = FsrRcasLoadF(sp + ivec2(0, 1)).rgb;
	 // Rename (32-bit) or regroup (16-bit).
	 float bR = b.r;
	 float bG = b.g;
	 float bB = b.b;
	 float dR = d.r;
	 float dG = d.g;
	 float dB = d.b;
	 float eR = e.r;
	 float eG = e.g;
	 float eB = e.b;
	 float fR = f.r;
	 float fG = f.g;
	 float fB = f.b;
	 float hR = h.r;
	 float hG = h.g;
	 float hB = h.b;
	 // Luma times 2.
	 float bL = bB * float(0.5) + (bR*float(0.5) + bG);
	 float dL = dB * float(0.5) + (dR*float(0.5) + dG);
	 float eL = eB * float(0.5) + (eR*float(0.5) + eG);
	 float fL = fB * float(0.5) + (fR*float(0.5) + fG);
	 float hL = hB * float(0.5) + (hR*float(0.5) + hG);
	 // Noise detection.
	 float nz = float(0.25)*bL + float(0.25)*dL + float(0.25)*fL + float(0.25)*hL - eL;
	 nz = clamp(abs(nz)*ARcpF1(AMax3F1(AMax3F1(bL, dL, eL), fL, hL) - AMin3F1(AMin3F1(bL, dL, eL), fL, hL)),0,1);
	 nz = float(-0.5)*nz + float(1.0);
	 // Min and max of ring.
	 float mn4R = min(AMin3F1(bR, dR, fR), hR);
	 float mn4G = min(AMin3F1(bG, dG, fG), hG);
	 float mn4B = min(AMin3F1(bB, dB, fB), hB);
	 float mx4R = max(AMax3F1(bR, dR, fR), hR);
	 float mx4G = max(AMax3F1(bG, dG, fG), hG);
	 float mx4B = max(AMax3F1(bB, dB, fB), hB);
	 // Immediate constants for peak range.
	 vec2 peakC = vec2(1.0, -1.0*4.0);
	 // Limiters, these need to be high precision RCPs.
	 float hitMinR = mn4R * ARcpF1(float(4.0)*mx4R);
	 float hitMinG = mn4G * ARcpF1(float(4.0)*mx4G);
	 float hitMinB = mn4B * ARcpF1(float(4.0)*mx4B);
	 float hitMaxR = (peakC.x - mx4R)*ARcpF1(float(4.0)*mn4R + peakC.y);
	 float hitMaxG = (peakC.x - mx4G)*ARcpF1(float(4.0)*mn4G + peakC.y);
	 float hitMaxB = (peakC.x - mx4B)*ARcpF1(float(4.0)*mn4B + peakC.y);
	 float lobeR = max(-hitMinR, hitMaxR);
	 float lobeG = max(-hitMinG, hitMaxG);
	 float lobeB = max(-hitMinB, hitMaxB);
	 float lobe = max(float(-FSR_RCAS_LIMIT), min(AMax3F1(lobeR, lobeG, lobeB), float(0.0)))*(con.x);
	 // Apply noise removal.
#ifdef FSR_RCAS_DENOISE
	 lobe *= nz;
#endif
	 // Resolve, which needs the medium precision rcp approximation to avoid visible tonality changes.
	 float rcpL = ARcpF1(float(4.0)*lobe + float(1.0));
	 pixR = (lobe*bR + lobe * dR + lobe * hR + lobe * fR + eR)*rcpL;
	 pixG = (lobe*bG + lobe * dG + lobe * hG + lobe * fG + eG)*rcpL;
	 pixB = (lobe*bB + lobe * dB + lobe * hB + lobe * fB + eB)*rcpL;
 }

void main()
{
	ivec2 FragPos = ivec2(gl_GlobalInvocationID.xy);
	vec3 color = vec3(0);
	FsrRcasF(color.r,color.g,color.b,FragPos);
	imageStore(u_OutputRCASImage, FragPos, vec4(color, 1));
}